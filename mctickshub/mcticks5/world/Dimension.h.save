#pragma once
#include <cstdio> // <--- 添加这个
#include "Chunk.h"
#include "LevelTicks.h"
#include "LightTick.h"
#include <string>
#include <random>
#include "BlockBehaviour.h"
#include "ChunkCoord.h"
#include "Block.h" // <--- 修复点 1: 添加了缺失的头文件

class Dimension {
public:
    // --- 修复点 2: 将所有成员变量移到使用它们的方法之前 ---
    LevelTicks blockTicks;
    std::unordered_map<ChunkCoord, Chunk, ChunkCoord::Hash> chunks;

    Dimension(const std::string &name) : blockTicks(LevelTicks()), random(std::random_device()()) {}

    ~Dimension() {}

    // 获取区块数据，不存在则创建
    Chunk* getChunk(const ChunkCoord& coord) {
        auto it = chunks.find(coord);
        if (it != chunks.end()) {
            return &it->second;
        } else {
            auto [new_it, inserted] = chunks.try_emplace(coord);
            return &new_it->second;
        }
    }

    // 维度的 tick，包含光照和方块行为
    void tick() {
        processTicks();
        lightTick(chunks);
    }

    // 处理所有计划刻
    void processTicks() {
        blockTicks.tick([this](BlockPos pos, LevelTicks &ticks) { this->tickBlock(pos, ticks);},
                        [this](BlockPos pos, int blockID) { this->tickSetBlockID(pos, blockID);});
    }

    // 统一执行 GO 发起的 SetBlock 得到的计划刻
    void setBlockTick() {
        blockTicks.setBlockTick([this](BlockPos pos, LevelTicks &ticks) { this->tickBlock(pos, ticks);},
                                [this](BlockPos pos, int blockID) { this->tickSetBlockID(pos, blockID);});
    }

    // 在所有计划刻之前的预处理，即设置方块 ID，不让方块的顺序影响行为
    void tickSetBlockID(const BlockPos& pos, int blockID) {
        setBlockID(pos, blockID);
    }

    // 执行方块的行为逻辑
    void tickBlock(BlockPos pos, LevelTicks &ticks) {
        int blockType = getBlockID(pos);
        BlockBehaviour* behaviour = globalBlockStateRegistry.getBlockStateBehaviour(blockType);
        behaviour->tick(this, pos, ticks);
        behaviour->randomTick(this, pos, random, ticks);
    }

    // 获取指定位置的方块 ID
    int getBlockID(const BlockPos& pos) {
        ChunkCoord chunkCoord = ChunkCoord::fromBlockPos(pos);
        auto chunkIt = chunks.find(chunkCoord);
        if (chunkIt == chunks.end()) {
            auto [it, inserted] = chunks.try_emplace(chunkCoord);
            if (inserted) {
                return 0;
            }
            chunkIt = it;
        }

        int relX = pos.x & 0xF;
        int relY = pos.y;
        int relZ = pos.z & 0xF;

        Chunk& chunk = chunkIt->second;
        return chunk.getBlockID(relX, relY, relZ);
    }

    // --- 修复点 3: 替换为包含光照补丁和拼写修正的 setBlockID ---
    // 设置指定位置的方块 ID
    void setBlockID(const BlockPos& pos, int blockID) {
        
        // --- 增量光照补丁 [开始] ---
        // 1. 在覆盖之前，获取旧的方块 ID
        int oldBlockID = getBlockID(pos);

        // 2. 获取旧方块的光照发射等级
        const BlockInfo* oldInfo = globalBlockRegistry.getBlockInfo(oldBlockID);
        int oldLightEmission = (oldInfo) ? oldInfo->visualProps.lightEmission : 0;
        // --- 增量光照补丁 [中段] ---


        ChunkCoord chunkCoord = ChunkCoord::fromBlockPos(pos);
        auto chunkIt = chunks.find(chunkCoord);
        if (chunkIt == chunks.end()) {
            auto [it, inserted] = chunks.try_emplace(chunkCoord);
            chunkIt = it;
        }
        int relX = pos.x & 0xF;
        int relY = pos.y;
        int relZ = pos.z & 0xF;

        Chunk& chunk = chunkIt->second;
        
        // 3. 真正设置新的方块 ID
        chunk.setBlockID(relX, relY, relZ, blockID);


        // --- 增量光照补丁 [末尾] ---
        // 4. 获取新方块的光照发射等级
        const BlockInfo* newInfo = globalBlockRegistry.getBlockInfo(blockID);
        int newLightEmission = (newInfo) ? newInfo->visualProps.lightEmission : 0;

        // 5. 如果光照等级有变化，则调用 LightTick.cpp 中的接口
        if (oldLightEmission != newLightEmission) {
            // (修正了拼写错误: addLightChang -> addLightChange)
            addLightChange(pos, oldLightEmission, newLightEmission);
        }
        // --- 增量光照补丁 [结束] ---
    }

private:
    // --- 修复点 2: (续) 将私有成员变量也移到顶部 ---
    int chunkCount = 0;
    std::string name;
    std::mt19937 random;
};
